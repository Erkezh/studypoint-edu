<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kazakh-fractions-app</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, sans-serif;
        }
        body.embed {
            padding: 0;
            background: transparent;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
      window.lucideReact = new Proxy({}, {
        get(_, name) {
          const toKebab = s => s.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
          return ({ size = 24, color, strokeWidth = 2, fill = 'none', className, ...props }) => {
            const ref = React.useRef();
            React.useEffect(() => {
              if (ref.current && lucide[toKebab(name)]) {
                ref.current.innerHTML = '';
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const iconData = lucide[toKebab(name)];
                svg.setAttribute('width', size);
                svg.setAttribute('height', size);
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('fill', fill);
                svg.setAttribute('stroke', color || 'currentColor');
                svg.setAttribute('stroke-width', strokeWidth);
                svg.setAttribute('stroke-linecap', 'round');
                svg.setAttribute('stroke-linejoin', 'round');
                if (className) svg.setAttribute('class', className);
                iconData[2].forEach(el => {
                  const node = document.createElementNS('http://www.w3.org/2000/svg', el[0]);
                  Object.entries(el[1] || {}).forEach(([k,v]) => node.setAttribute(k, v));
                  svg.appendChild(node);
                });
                ref.current.appendChild(svg);
              }
            }, [size, color, strokeWidth, fill, className]);
            return React.createElement('span', { ref, style: { display: 'inline-flex' }, ...props });
          };
        }
      });
    </script>
    <script type="text/babel">
        const embedMode = /[?&]embed=1/i.test(window.location.search);
        if (embedMode) {
            document.body.classList.add('embed');
        }
        
        const { useState, useEffect } = React;
const { CheckCircle, XCircle, RotateCcw, Play } = window.lucideReact;

const KazakhFractionsApp = () => {
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [userAnswer, setUserAnswer] = useState('');
  const [feedback, setFeedback] = useState(null);
  const [score, setScore] = useState({ correct: 0, total: 0 });
  const [questionHistory, setQuestionHistory] = useState([]);

  // Kazakh translations
  const kazakh = {
    title: "Бөлшектерді үйрену",
    question: "Сұрақ",
    answer: "Жауап",
    correct: "Дұрыс!",
    incorrect: "Қате!",
    nextQuestion: "Келесі сұрақ",
    tryAgain: "Қайта көру",
    score: "Нәтиже",
    numberLine: "Сан түзуінде көрсетілген бөлшек қандай?",
    shapeFraction: "Боялған бөлігі қай бөлшекке тең?",
    shapeCount: "Фигуралардың қандай бөлшегі",
    circles: "дөңгелектер",
    squares: "төртбұрыштар", 
    triangles: "үшбұрыштар",
    stars: "жұлдыздар",
    hexagons: "алтыбұрыштар",
    notStars: "жұлдыз емес",
    notRectangles: "төртбұрыш емес",
    instruction: "Бөлгіш үшін / белгісін қолданыңыз (мысалы: 1/2)",
    check: "Тексеру",
    showAnswer: "Жауапты көрсету"
  };

  // Helper functions for fraction equivalence
  const gcd = (a, b) => {
    while (b !== 0) {
      const temp = b;
      b = a % b;
      a = temp;
    }
    return a;
  };

  const simplifyFraction = (numerator, denominator) => {
    const divisor = gcd(numerator, denominator);
    return {
      numerator: numerator / divisor,
      denominator: denominator / divisor
    };
  };

  const parseFraction = (fractionStr) => {
    const parts = fractionStr.trim().split('/');
    if (parts.length !== 2) return null;
    
    const numerator = parseInt(parts[0]);
    const denominator = parseInt(parts[1]);
    
    if (isNaN(numerator) || isNaN(denominator) || denominator === 0) return null;
    
    return { numerator, denominator };
  };

  const areFractionsEqual = (fraction1Str, fraction2Str) => {
    const f1 = parseFraction(fraction1Str);
    const f2 = parseFraction(fraction2Str);
    
    if (!f1 || !f2) return false;
    
    const simplified1 = simplifyFraction(f1.numerator, f1.denominator);
    const simplified2 = simplifyFraction(f2.numerator, f2.denominator);
    
    return simplified1.numerator === simplified2.numerator && 
           simplified1.denominator === simplified2.denominator;
  };

  // Question generators
  const generateNumberLineQuestion = () => {
    const denominators = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    const denominator = denominators[Math.floor(Math.random() * denominators.length)];
    const numerator = Math.floor(Math.random() * (denominator - 1)) + 1;
    
    return {
      type: 'numberLine',
      question: kazakh.numberLine,
      answer: `${numerator}/${denominator}`,
      visual: { numerator, denominator },
      instruction: kazakh.instruction
    };
  };

  const generateShapeCountQuestion = () => {
    const shapeTypes = [
      { name: kazakh.circles, color: '#3b82f6' },
      { name: kazakh.squares, color: '#ef4444' },
      { name: kazakh.triangles, color: '#22c55e' },
      { name: kazakh.stars, color: '#f59e0b' },
      { name: kazakh.hexagons, color: '#8b5cf6' }
    ];
    
    const totalShapes = Math.floor(Math.random() * 6) + 5; // 5-10 shapes
    const targetType = Math.floor(Math.random() * shapeTypes.length);
    const targetCount = Math.floor(Math.random() * Math.min(4, totalShapes)) + 1;
    
    const shapes = [];
    for (let i = 0; i < targetCount; i++) {
      shapes.push(targetType);
    }
    for (let i = targetCount; i < totalShapes; i++) {
      let otherType;
      do {
        otherType = Math.floor(Math.random() * shapeTypes.length);
      } while (otherType === targetType);
      shapes.push(otherType);
    }
    
    // Shuffle shapes
    for (let i = shapes.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shapes[i], shapes[j]] = [shapes[j], shapes[i]];
    }
    
    return {
      type: 'shapeCount',
      question: `${kazakh.shapeCount} ${shapeTypes[targetType].name}?`,
      answer: `${targetCount}/${totalShapes}`,
      visual: { shapes, shapeTypes, targetType, targetCount, totalShapes },
      instruction: kazakh.instruction
    };
  };

  const generateColoredShapeQuestion = () => {
    const denominators = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    const denominator = denominators[Math.floor(Math.random() * denominators.length)];
    const numerator = Math.floor(Math.random() * denominator) + 1;
    
    return {
      type: 'coloredShape',
      question: kazakh.shapeFraction,
      answer: `${numerator}/${denominator}`,
      visual: { numerator, denominator },
      instruction: kazakh.instruction
    };
  };

  const generateQuestion = () => {
    const generators = [generateNumberLineQuestion, generateShapeCountQuestion, generateColoredShapeQuestion];
    const generator = generators[Math.floor(Math.random() * generators.length)];
    return generator();
  };

  const renderNumberLine = (numerator, denominator) => {
    const position = (numerator / denominator) * 300 + 50;
    
    return (
      <div className="my-8">
        <svg width="400" height="80" className="mx-auto block">
          {/* Main line */}
          <line x1="50" y1="40" x2="350" y2="40" stroke="#374151" strokeWidth="2"/>
          
          {/* Tick marks */}
          {Array.from({length: denominator + 1}).map((_, i) => {
            const x = 50 + (i * 300 / denominator);
            return (
              <line key={i} x1={x} y1="35" x2={x} y2="45" stroke="#374151" strokeWidth="1"/>
            );
          })}
          
          {/* Numbers */}
          <text x="50" y="60" textAnchor="middle" className="fill-gray-700 text-sm">0</text>
          <text x="350" y="60" textAnchor="middle" className="fill-gray-700 text-sm">1</text>
          
          {/* Point */}
          <circle cx={position} cy="40" r="4" fill="#ef4444"/>
        </svg>
      </div>
    );
  };

  const renderShapes = (shapes, shapeTypes) => {
    const renderShape = (type, index) => {
      const size = 30;
      const color = shapeTypes[type].color;
      
      switch (type) {
        case 0: // circle
          return <circle key={index} cx="15" cy="15" r="12" fill={color} stroke="#374151" strokeWidth="1"/>;
        case 1: // square
          return <rect key={index} x="3" y="3" width="24" height="24" fill={color} stroke="#374151" strokeWidth="1"/>;
        case 2: // triangle
          return <polygon key={index} points="15,3 27,24 3,24" fill={color} stroke="#374151" strokeWidth="1"/>;
        case 3: // star
          return <polygon key={index} points="15,2 18,11 28,11 20,18 23,28 15,22 7,28 10,18 2,11 12,11" fill={color} stroke="#374151" strokeWidth="1"/>;
        case 4: // hexagon
          return <polygon key={index} points="15,3 25,9 25,21 15,27 5,21 5,9" fill={color} stroke="#374151" strokeWidth="1"/>;
        default:
          return null;
      }
    };

    return (
      <div className="flex flex-wrap gap-3 justify-center my-6 p-4 border rounded-lg bg-gray-50">
        {shapes.map((shapeType, index) => (
          <svg key={index} width="30" height="30" className="border rounded">
            {renderShape(shapeType, index)}
          </svg>
        ))}
      </div>
    );
  };

  const renderColoredCircle = (numerator, denominator) => {
    const angleStep = (2 * Math.PI) / denominator;
    const centerX = 60;
    const centerY = 60;
    const radius = 50;

    return (
      <div className="flex justify-center my-8">
        <svg width="120" height="120">
          <circle cx={centerX} cy={centerY} r={radius} fill="white" stroke="#374151" strokeWidth="2"/>
          
          {/* Dividing lines */}
          {Array.from({length: denominator}).map((_, i) => {
            const angle = i * angleStep;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            return (
              <line 
                key={i} 
                x1={centerX} 
                y1={centerY} 
                x2={x} 
                y2={y} 
                stroke="#374151" 
                strokeWidth="1"
              />
            );
          })}
          
          {/* Colored sections */}
          {Array.from({length: numerator}).map((_, i) => {
            const startAngle = i * angleStep - Math.PI / 2;
            const endAngle = (i + 1) * angleStep - Math.PI / 2;
            
            const x1 = centerX + Math.cos(startAngle) * radius;
            const y1 = centerY + Math.sin(startAngle) * radius;
            const x2 = centerX + Math.cos(endAngle) * radius;
            const y2 = centerY + Math.sin(endAngle) * radius;
            
            const largeArc = angleStep > Math.PI ? 1 : 0;
            
            const pathData = [
              `M ${centerX} ${centerY}`,
              `L ${x1} ${y1}`,
              `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`,
              'Z'
            ].join(' ');
            
            return (
              <path 
                key={i} 
                d={pathData} 
                fill="#3b82f6" 
                stroke="#374151" 
                strokeWidth="1"
              />
            );
          })}
        </svg>
      </div>
    );
  };

  const checkAnswer = () => {
    if (!userAnswer.trim()) return;
    
    const isCorrect = areFractionsEqual(userAnswer.trim(), currentQuestion.answer);
    setFeedback({ correct: isCorrect, answer: currentQuestion.answer });
    
    const newScore = {
      correct: score.correct + (isCorrect ? 1 : 0),
      total: score.total + 1
    };
    setScore(newScore);
    
    setQuestionHistory([...questionHistory, {
      question: currentQuestion,
      userAnswer: userAnswer,
      correct: isCorrect
    }]);

    // Auto advance to next question if correct
    if (isCorrect) {
      setTimeout(() => {
        nextQuestion();
      }, 1500); // Wait 1.5 seconds to show feedback
    }
  };

  const nextQuestion = () => {
    setCurrentQuestion(generateQuestion());
    setUserAnswer('');
    setFeedback(null);
  };

  const resetGame = () => {
    setScore({ correct: 0, total: 0 });
    setQuestionHistory([]);
    setFeedback(null);
    setUserAnswer('');
    nextQuestion();
  };

  useEffect(() => {
    nextQuestion();
  }, []);

  if (!currentQuestion) return <div>Жүктелуде...</div>;

  return (
    <div className="max-w-4xl mx-auto p-6 bg-white">
      <div className="text-center mb-8">
        <h1 className="text-3xl font-bold text-blue-600 mb-2">{kazakh.title}</h1>
      </div>

      <div className="bg-gray-50 rounded-lg p-6 mb-6">
        <p className="text-lg mb-6">{currentQuestion.question}</p>
        
        {/* Render visual based on question type */}
        {currentQuestion.type === 'numberLine' && renderNumberLine(
          currentQuestion.visual.numerator, 
          currentQuestion.visual.denominator
        )}
        
        {currentQuestion.type === 'shapeCount' && renderShapes(
          currentQuestion.visual.shapes,
          currentQuestion.visual.shapeTypes
        )}
        
        {currentQuestion.type === 'coloredShape' && renderColoredCircle(
          currentQuestion.visual.numerator,
          currentQuestion.visual.denominator
        )}
        
        <p className="text-sm text-gray-600 mb-4">{currentQuestion.instruction}</p>
        
        <div className="flex gap-4 items-center">
          <input
            type="text"
            value={userAnswer}
            onChange={(e) => setUserAnswer(e.target.value)}
            placeholder="1/2"
            className="border border-gray-300 rounded px-4 py-2 text-lg w-32"
            disabled={feedback !== null}
          />
          
          {!feedback ? (
            <button
              onClick={checkAnswer}
              disabled={!userAnswer.trim()}
              className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 disabled:bg-gray-400 flex items-center gap-2"
            >
              <CheckCircle size={20} />
              {kazakh.check}
            </button>
          ) : (
            !feedback.correct && (
              <button
                onClick={nextQuestion}
                className="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700 flex items-center gap-2"
              >
                <Play size={20} />
                {kazakh.nextQuestion}
              </button>
            )
          )}
        </div>
        
        {feedback && (
          <div className={`mt-4 p-4 rounded-lg ${feedback.correct ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
            <div className="flex items-center gap-2">
              {feedback.correct ? <CheckCircle size={20} /> : <XCircle size={20} />}
              <span className="font-semibold">
                {feedback.correct ? kazakh.correct : kazakh.incorrect}
              </span>
            </div>
            {!feedback.correct && (
              <p className="mt-2">Дұрыс жауап: <strong>{feedback.answer}</strong></p>
            )}
          </div>
        )}
      </div>

    </div>
  );
};


        
        ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(KazakhFractionsApp));
        
        // Отправляем INIT сообщение
        if (embedMode && window.parent) {
            window.parent.postMessage({ type: 'INIT', status: 'ready' }, '*');
        }
    </script>
</body>
</html>