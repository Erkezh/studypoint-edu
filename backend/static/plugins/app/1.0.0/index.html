<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>app</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, sans-serif;
        }
        body.embed {
            padding: 0;
            background: transparent;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script>
      window.lucideReact = new Proxy({}, {
        get(_, name) {
          const toKebab = s => s.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
          return ({ size = 24, color, strokeWidth = 2, fill = 'none', className, ...props }) => {
            const ref = React.useRef();
            React.useEffect(() => {
              if (ref.current && lucide[toKebab(name)]) {
                ref.current.innerHTML = '';
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                const iconData = lucide[toKebab(name)];
                svg.setAttribute('width', size);
                svg.setAttribute('height', size);
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('fill', fill);
                svg.setAttribute('stroke', color || 'currentColor');
                svg.setAttribute('stroke-width', strokeWidth);
                svg.setAttribute('stroke-linecap', 'round');
                svg.setAttribute('stroke-linejoin', 'round');
                if (className) svg.setAttribute('class', className);
                iconData[2].forEach(el => {
                  const node = document.createElementNS('http://www.w3.org/2000/svg', el[0]);
                  Object.entries(el[1] || {}).forEach(([k,v]) => node.setAttribute(k, v));
                  svg.appendChild(node);
                });
                ref.current.appendChild(svg);
              }
            }, [size, color, strokeWidth, fill, className]);
            return React.createElement('span', { ref, style: { display: 'inline-flex' }, ...props });
          };
        }
      });
    </script>
    <script>
        (function() {
            const embedMode = /[?&]embed=1/i.test(window.location.search);
            if (embedMode) {
                document.body.classList.add('embed');
            }
            
            const { useState, useEffect, useRef, useCallback } = React;
const FONT = "Verdana, sans-serif";
const CHECK_COLOR = "#323048";
const fmt = (n, p) => Number(n).toFixed(p);
const feq = (a, b) => Math.abs(a - b) < 1e-4;
const generateProblem = () => {
  const allTypes = [
    "compare",
    "greater",
    "smaller",
    "closerTo",
    "graphCompare",
    "graphGreater",
    "graphSmaller",
    "graphCloser"
  ];
  const taskType = allTypes[Math.floor(Math.random() * allTypes.length)];
  const places = Math.random() > 0.4 ? 2 : 1;
  let rangeMin, rangeMax, step;
  const ticks = [];
  if (places === 1) {
    const base = Math.floor(Math.random() * 10);
    rangeMin = base;
    rangeMax = base + 1;
    step = 0.1;
    for (let i = 0; i <= 10; i++) ticks.push(+(rangeMin + i * 0.1).toFixed(1));
  } else {
    const w = Math.floor(Math.random() * 10);
    const t = Math.floor(Math.random() * 10);
    rangeMin = +(w + t * 0.1).toFixed(1);
    rangeMax = +(rangeMin + 0.1).toFixed(1);
    step = 0.01;
    for (let i = 0; i <= 10; i++) ticks.push(+(rangeMin + i * 0.01).toFixed(2));
  }
  const idxA = Math.floor(Math.random() * 11);
  let idxB = idxA;
  while (idxB === idxA) idxB = Math.floor(Math.random() * 11);
  let a = ticks[idxA];
  let b = ticks[idxB];
  let target;
  if (taskType === "closerTo" || taskType === "graphCloser") {
    const dAmin = Math.abs(a - rangeMin);
    const dBmin = Math.abs(b - rangeMin);
    const dAmax = Math.abs(a - rangeMax);
    const dBmax = Math.abs(b - rangeMax);
    if (Math.abs(dAmin - dBmin) > 1e-3) {
      target = rangeMin;
    } else if (Math.abs(dAmax - dBmax) > 1e-3) {
      target = rangeMax;
    } else {
      target = rangeMin;
      a = ticks[2];
      b = ticks[8];
    }
  }
  const fa = fmt(a, places);
  const fb = fmt(b, places);
  let question = "";
  let correctAnswer = "";
  const isGraph = taskType.startsWith("graph");
  const core = taskType.replace("graph", "").toLowerCase();
  if (isGraph) {
    question = `${fa} \u0436\u04D9\u043D\u0435 ${fb} \u0441\u0430\u043D\u0434\u0430\u0440\u044B\u043D \u0441\u0430\u043D \u0441\u044B\u0437\u044B\u0493\u044B\u043D\u0430 \u043E\u0440\u043D\u0430\u043B\u0430\u0441\u0442\u044B\u0440`;
  }
  switch (core === "closer" ? "closerTo" : core) {
    case "compare":
      if (!isGraph) question = `${fa} \u0436\u04D9\u043D\u0435 ${fb} \u0441\u0430\u043D\u0434\u0430\u0440\u044B\u043D \u0441\u0430\u043B\u044B\u0441\u0442\u044B\u0440`;
      correctAnswer = a < b ? "<" : ">";
      break;
    case "greater":
      if (!isGraph) question = `\u049A\u0430\u0439 \u0441\u0430\u043D \u04AF\u043B\u043A\u0435\u043D: ${fa} \u043D\u0435\u043C\u0435\u0441\u0435 ${fb}?`;
      correctAnswer = fmt(a > b ? a : b, places);
      break;
    case "smaller":
      if (!isGraph) question = `\u049A\u0430\u0439 \u0441\u0430\u043D \u043A\u0456\u0448\u0456: ${fa} \u043D\u0435\u043C\u0435\u0441\u0435 ${fb}?`;
      correctAnswer = fmt(a < b ? a : b, places);
      break;
    case "closerTo": {
      const ft = fmt(target, places);
      if (!isGraph) question = `\u049A\u0430\u0439 \u0441\u0430\u043D ${ft} \u0441\u0430\u043D\u044B\u043D\u0430 \u0436\u0430\u049B\u044B\u043D: ${fa} \u043D\u0435\u043C\u0435\u0441\u0435 ${fb}?`;
      const dA = Math.abs(a - target);
      const dB = Math.abs(b - target);
      correctAnswer = fmt(dA < dB ? a : b, places);
      break;
    }
  }
  return {
    id: Date.now() + Math.random(),
    question,
    correctAnswer,
    taskType,
    a,
    b,
    places,
    rangeMin,
    rangeMax,
    step,
    tickValues: ticks,
    target,
    visualData: {
      type: "numberline",
      numberline: {
        min: rangeMin,
        max: rangeMax,
        step,
        places,
        tickValues: ticks,
        markerA: a,
        markerB: b,
        target
      }
    }
  };
};
const NumberLine = ({ rangeMin, rangeMax, places, tickValues, markers, interactive, onPlace, step: stp }) => {
  const svgRef = useRef(null);
  const pad = 30;
  const W = 500;
  const H = 60;
  const Y = 30;
  const uW = W - pad * 2;
  const getX = (v) => pad + (v - rangeMin) / (rangeMax - rangeMin || 1) * uW;
  const labels = places === 2 ? [0, 5, 10] : null;
  const click = (e) => {
    if (!interactive || !onPlace || !svgRef.current) return;
    const r = svgRef.current.getBoundingClientRect();
    if (r.width === 0) return;
    const sc = W / r.width;
    const cx = (e.clientX - r.left) * sc;
    const v = rangeMin + (cx - pad) / uW * (rangeMax - rangeMin);
    const sn = Math.round(v / stp) * stp;
    const cl = Math.max(rangeMin, Math.min(rangeMax, +sn.toFixed(places)));
    onPlace(cl);
  };
  return /* @__PURE__ */ React.createElement(
    "svg",
    {
      ref: svgRef,
      viewBox: `0 0 ${W} ${H}`,
      onClick: click,
      style: { width: "100%", maxWidth: 500, height: "auto", cursor: interactive ? "crosshair" : "default", display: "block", margin: "0 auto" }
    },
    /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("marker", { id: "aL", markerWidth: "8", markerHeight: "8", refX: "8", refY: "4", orient: "auto" }, /* @__PURE__ */ React.createElement("path", { d: "M8,0 L0,4 L8,8", fill: "none", stroke: "#888", strokeWidth: "1.5" })), /* @__PURE__ */ React.createElement("marker", { id: "aR", markerWidth: "8", markerHeight: "8", refX: "0", refY: "4", orient: "auto" }, /* @__PURE__ */ React.createElement("path", { d: "M0,0 L8,4 L0,8", fill: "none", stroke: "#888", strokeWidth: "1.5" }))),
    /* @__PURE__ */ React.createElement("line", { x1: pad - 20, y1: Y, x2: W - pad + 20, y2: Y, stroke: "#888", strokeWidth: "1.5", markerStart: "url(#aL)", markerEnd: "url(#aR)" }),
    tickValues.map((v, i) => {
      const x = getX(v);
      const show = labels ? labels.includes(i) : true;
      return /* @__PURE__ */ React.createElement("g", { key: i }, /* @__PURE__ */ React.createElement("line", { x1: x, y1: Y - 6, x2: x, y2: Y + 6, stroke: "#888", strokeWidth: "1" }), show && /* @__PURE__ */ React.createElement("text", { x, y: Y + 20, textAnchor: "middle", fontSize: "10", fill: "#444", fontFamily: FONT }, fmt(v, places)));
    }),
    markers.map((v, i) => /* @__PURE__ */ React.createElement("circle", { key: `${i}-${v}`, cx: getX(v), cy: Y, r: 5, fill: "#4a9fd5", stroke: "#fff", strokeWidth: "1.5" }))
  );
};
const CheckBtn = ({ onClick, disabled }) => /* @__PURE__ */ React.createElement("div", { style: { marginTop: 20, textAlign: "center" } }, /* @__PURE__ */ React.createElement("button", { onClick, disabled, style: {
  padding: "11px 36px",
  background: CHECK_COLOR,
  color: "#fff",
  border: "none",
  borderRadius: 6,
  fontSize: "clamp(14px, 3.5vw, 16px)",
  fontFamily: FONT,
  cursor: disabled ? "default" : "pointer",
  opacity: disabled ? 0.5 : 1,
  letterSpacing: 0.3
} }, "\u0422\u0435\u043A\u0441\u0435\u0440\u0443"));
const UnderstoodBtn = ({ onClick }) => /* @__PURE__ */ React.createElement("button", { onClick, style: {
  padding: "10px 28px",
  background: "#fff",
  color: CHECK_COLOR,
  border: `1.5px solid ${CHECK_COLOR}`,
  borderRadius: 6,
  fontSize: "clamp(13px, 3vw, 15px)",
  fontFamily: FONT,
  cursor: "pointer"
} }, "\u0422\u04AF\u0441\u0456\u043D\u0434\u0456\u043C");
const CorrectMsg = () => /* @__PURE__ */ React.createElement("div", { style: { marginTop: 20, textAlign: "center" } }, /* @__PURE__ */ React.createElement("div", { style: { display: "inline-flex", alignItems: "center", gap: 8, color: "#2e7d32", fontSize: "clamp(16px, 4vw, 20px)", fontFamily: FONT } }, /* @__PURE__ */ React.createElement("span", { style: { fontSize: "clamp(20px, 5vw, 26px)" } }, "\u2713"), " \u0414\u04B1\u0440\u044B\u0441"));
const WrongMsg = ({ explanation, onUnderstood }) => /* @__PURE__ */ React.createElement("div", { style: { marginTop: 20, textAlign: "center" } }, /* @__PURE__ */ React.createElement("div", { style: { color: "#c62828", fontSize: "clamp(16px, 4vw, 20px)", fontFamily: FONT, marginBottom: 10 } }, "\u049A\u0430\u0442\u0435"), /* @__PURE__ */ React.createElement("p", { style: { fontSize: "clamp(12px, 3vw, 14px)", fontFamily: FONT, color: "#555", maxWidth: 400, margin: "0 auto 14px", lineHeight: 1.5 } }, explanation), /* @__PURE__ */ React.createElement(UnderstoodBtn, { onClick: onUnderstood }));
const getExplanation = (p, subType) => {
  const fa = fmt(p.a, p.places);
  const fb = fmt(p.b, p.places);
  const t = subType || p.taskType;
  if (t === "compare" || t === "graphCompare") {
    const op = p.a < p.b ? "<" : ">";
    const side = p.a < p.b ? "\u0441\u043E\u043B \u0436\u0430\u049B\u0442\u0430" : "\u043E\u04A3 \u0436\u0430\u049B\u0442\u0430";
    return `${fa} \u0441\u0430\u043D\u044B \u0441\u0430\u043D \u0441\u044B\u0437\u044B\u0493\u044B\u043D\u0434\u0430 ${fb} \u0441\u0430\u043D\u044B\u043D\u0430\u043D ${side} \u043E\u0440\u043D\u0430\u043B\u0430\u0441\u049B\u0430\u043D, \u0441\u043E\u043D\u0434\u044B\u049B\u0442\u0430\u043D ${fa} ${op} ${fb}`;
  }
  if (t === "greater" || t === "graphGreater") {
    const cv = fmt(p.a > p.b ? p.a : p.b, p.places);
    return `\u0421\u0430\u043D \u0441\u044B\u0437\u044B\u0493\u044B\u043D\u0434\u0430 \u043E\u04A3\u0493\u0430 \u049B\u0430\u0440\u0430\u0439 \u043E\u0440\u043D\u0430\u043B\u0430\u0441\u049B\u0430\u043D \u0441\u0430\u043D \u04AF\u043B\u043A\u0435\u043D\u0456\u0440\u0435\u043A. ${cv} \u2014 \u04AF\u043B\u043A\u0435\u043D \u0441\u0430\u043D.`;
  }
  if (t === "smaller" || t === "graphSmaller") {
    const cv = fmt(p.a < p.b ? p.a : p.b, p.places);
    return `\u0421\u0430\u043D \u0441\u044B\u0437\u044B\u0493\u044B\u043D\u0434\u0430 \u0441\u043E\u043B\u0493\u0430 \u049B\u0430\u0440\u0430\u0439 \u043E\u0440\u043D\u0430\u043B\u0430\u0441\u049B\u0430\u043D \u0441\u0430\u043D \u043A\u0456\u0448\u0456\u0440\u0435\u043A. ${cv} \u2014 \u043A\u0456\u0448\u0456 \u0441\u0430\u043D.`;
  }
  if (t === "closerTo" || t === "graphCloser") {
    const dA = Math.abs(p.a - p.target);
    const dB = Math.abs(p.b - p.target);
    const cv = fmt(dA < dB ? p.a : p.b, p.places);
    const ft = fmt(p.target, p.places);
    return `${cv} \u0441\u0430\u043D\u044B ${ft} \u0441\u0430\u043D\u044B\u043D\u0430 \u0436\u0430\u049B\u044B\u043D\u044B\u0440\u0430\u049B \u043E\u0440\u043D\u0430\u043B\u0430\u0441\u049B\u0430\u043D.`;
  }
  return "";
};
const getTitle = (t) => {
  switch (t) {
    case "compare":
    case "graphCompare":
      return "\u041E\u043D\u0434\u044B\u049B \u0431\u04E9\u043B\u0448\u0435\u043A\u0442\u0435\u0440\u0434\u0456 \u0441\u0430\u043B\u044B\u0441\u0442\u044B\u0440";
    case "greater":
    case "graphGreater":
      return "\u049A\u0430\u0439 \u0441\u0430\u043D \u04AF\u043B\u043A\u0435\u043D?";
    case "smaller":
    case "graphSmaller":
      return "\u049A\u0430\u0439 \u0441\u0430\u043D \u043A\u0456\u0448\u0456?";
    case "closerTo":
    case "graphCloser":
      return "\u049A\u0430\u0439 \u0441\u0430\u043D \u0436\u0430\u049B\u044B\u043D?";
  }
};
const DecimalNumberLine = () => {
  const [problem, setProblem] = useState(null);
  const [userAnswer, setUserAnswer] = useState("");
  const [showResult, setShowResult] = useState(false);
  const [isCorrect, setIsCorrect] = useState(false);
  const [graphMarkers, setGraphMarkers] = useState([]);
  const [graphPhase, setGraphPhase] = useState("place");
  const [graphChecked, setGraphChecked] = useState(false);
  const [graphCorrect, setGraphCorrect] = useState(false);
  const containerRef = useRef(null);
  const sendHeight = useCallback(() => {
    if (window.parent !== window && containerRef.current) {
      window.parent.postMessage({ type: "resize", height: containerRef.current.scrollHeight + 20 }, "*");
    }
  }, []);
  useEffect(() => {
    setProblem(generateProblem());
  }, []);
  useEffect(() => {
    sendHeight();
    const t = setTimeout(sendHeight, 100);
    return () => clearTimeout(t);
  }, [problem, showResult, graphPhase, graphChecked, sendHeight]);
  const handleSubmit = useCallback(() => {
    if (!problem || !userAnswer) return;
    const correct = userAnswer === problem.correctAnswer;
    setIsCorrect(correct);
    setShowResult(true);
    window.parent.postMessage({
      type: "exercise-result",
      isCorrect: correct,
      question: problem.question,
      userAnswer,
      correctAnswer: problem.correctAnswer,
      questionData: problem.visualData
    }, "*");
    if (correct) {
      setTimeout(() => {
        handleNext();
      }, 1200);
    }
  }, [problem, userAnswer]);
  const handleNext = useCallback(() => {
    setProblem(generateProblem());
    setUserAnswer("");
    setShowResult(false);
    setIsCorrect(false);
    setGraphMarkers([]);
    setGraphPhase("place");
    setGraphChecked(false);
    setGraphCorrect(false);
  }, []);
  const handleRetry = useCallback(() => {
    setUserAnswer("");
    setShowResult(false);
    setIsCorrect(false);
  }, []);
  const handlePlaceMarker = useCallback((val) => {
    if (graphMarkers.length >= 2) return;
    if (graphMarkers.some((m) => feq(m, val))) return;
    setGraphMarkers((prev) => [...prev, val]);
  }, [graphMarkers]);
  const removeMarker = useCallback((idx) => {
    setGraphMarkers((prev) => prev.filter((_, i) => i !== idx));
  }, []);
  const handleCheckGraph = useCallback(() => {
    if (!problem || graphMarkers.length !== 2) return;
    const sorted = [...graphMarkers].sort((x, y) => x - y);
    const expected = [problem.a, problem.b].sort((x, y) => x - y);
    const ok = feq(sorted[0], expected[0]) && feq(sorted[1], expected[1]);
    setGraphCorrect(ok);
    setGraphChecked(true);
    if (ok) {
      setTimeout(() => {
        setGraphPhase("answer");
        setGraphChecked(false);
        setGraphCorrect(false);
      }, 1e3);
    }
  }, [problem, graphMarkers]);
  const handleRetryGraph = useCallback(() => {
    setGraphMarkers([]);
    setGraphChecked(false);
    setGraphCorrect(false);
  }, []);
  if (!problem) return null;
  const fa = fmt(problem.a, problem.places);
  const fb = fmt(problem.b, problem.places);
  const ft = problem.target != null ? fmt(problem.target, problem.places) : "";
  const isGraph = problem.taskType.startsWith("graph");
  const coreType = problem.taskType.replace("graph", "");
  const coreLC = coreType.charAt(0).toLowerCase() + coreType.slice(1);
  const getSubPrompt = () => {
    switch (coreLC) {
      case "compare":
        return "\u0421\u0430\u043B\u044B\u0441\u0442\u044B\u0440:";
      case "greater":
        return "\u049A\u0430\u0439 \u0441\u0430\u043D \u04AF\u043B\u043A\u0435\u043D?";
      case "smaller":
        return "\u049A\u0430\u0439 \u0441\u0430\u043D \u043A\u0456\u0448\u0456?";
      case "closer":
        return `\u049A\u0430\u0439 \u0441\u0430\u043D ${ft} \u0441\u0430\u043D\u044B\u043D\u0430 \u0436\u0430\u049B\u044B\u043D?`;
      default:
        return "";
    }
  };
  const getSubCorrect = () => {
    switch (coreLC) {
      case "compare":
        return problem.a < problem.b ? "<" : ">";
      case "greater":
        return fmt(problem.a > problem.b ? problem.a : problem.b, problem.places);
      case "smaller":
        return fmt(problem.a < problem.b ? problem.a : problem.b, problem.places);
      case "closer": {
        const dA = Math.abs(problem.a - problem.target);
        const dB = Math.abs(problem.b - problem.target);
        return fmt(dA < dB ? problem.a : problem.b, problem.places);
      }
      default:
        return "";
    }
  };
  const renderCompareOptions = (current, onSelect, disabled) => /* @__PURE__ */ React.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 10, marginTop: 12, flexWrap: "wrap" } }, /* @__PURE__ */ React.createElement("span", { style: { fontSize: "clamp(16px, 4vw, 20px)", fontFamily: FONT } }, fa), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: 6 } }, ["<", ">"].map((op) => /* @__PURE__ */ React.createElement("button", { key: op, onClick: () => {
    if (!disabled) onSelect(op);
  }, style: {
    width: 44,
    height: 44,
    border: current === op ? "2px solid #4a9fd5" : "1px solid #ccc",
    background: current === op ? "#e8f4fc" : "#fff",
    borderRadius: 6,
    fontSize: 20,
    fontFamily: FONT,
    cursor: disabled ? "default" : "pointer",
    color: "#333",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  } }, op))), /* @__PURE__ */ React.createElement("span", { style: { fontSize: "clamp(16px, 4vw, 20px)", fontFamily: FONT } }, fb));
  const renderChoiceOptions = (current, onSelect, disabled) => /* @__PURE__ */ React.createElement("div", { style: { display: "flex", justifyContent: "center", gap: 12, marginTop: 12 } }, [problem.a, problem.b].map((val) => {
    const fv = fmt(val, problem.places);
    const selected = current === fv;
    return /* @__PURE__ */ React.createElement("button", { key: fv, onClick: () => {
      if (!disabled) onSelect(fv);
    }, style: {
      padding: "10px 22px",
      border: selected ? "2px solid #4a9fd5" : "1px solid #ccc",
      background: selected ? "#e8f4fc" : "#fff",
      borderRadius: 6,
      fontSize: "clamp(15px, 3.5vw, 18px)",
      fontFamily: FONT,
      cursor: disabled ? "default" : "pointer",
      color: "#333",
      minWidth: 60
    } }, fv);
  }));
  const renderGraphPlace = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", { style: { textAlign: "center", fontSize: "clamp(11px, 2.5vw, 13px)", fontFamily: FONT, color: "#999", marginBottom: 8 } }, "\u0421\u0430\u043D \u0441\u044B\u0437\u044B\u0493\u044B\u043D \u0431\u0430\u0441\u044B\u04A3\u044B\u0437"), /* @__PURE__ */ React.createElement(
    NumberLine,
    {
      rangeMin: problem.rangeMin,
      rangeMax: problem.rangeMax,
      places: problem.places,
      tickValues: problem.tickValues,
      markers: graphMarkers,
      step: problem.step,
      interactive: !graphChecked,
      onPlace: handlePlaceMarker
    }
  ), graphMarkers.length > 0 && !graphChecked && /* @__PURE__ */ React.createElement("div", { style: { display: "flex", justifyContent: "center", gap: 8, marginTop: 8, flexWrap: "wrap" } }, graphMarkers.map((m, i) => /* @__PURE__ */ React.createElement("span", { key: `${i}-${m}`, onClick: () => removeMarker(i), style: {
    background: "#e8f4fc",
    padding: "4px 10px",
    borderRadius: 4,
    fontSize: 13,
    fontFamily: FONT,
    cursor: "pointer",
    color: "#4a9fd5",
    border: "1px solid #4a9fd5"
  } }, fmt(m, problem.places), " \u2715"))), !graphChecked && /* @__PURE__ */ React.createElement(CheckBtn, { onClick: handleCheckGraph, disabled: graphMarkers.length !== 2 }), graphChecked && graphCorrect && /* @__PURE__ */ React.createElement(CorrectMsg, null), graphChecked && !graphCorrect && /* @__PURE__ */ React.createElement(WrongMsg, { explanation: `${fa} \u0436\u04D9\u043D\u0435 ${fb} \u0441\u0430\u043D\u0434\u0430\u0440\u044B\u043D \u0434\u04B1\u0440\u044B\u0441 \u043E\u0440\u044B\u043D\u0493\u0430 \u049B\u043E\u0439.`, onUnderstood: handleRetryGraph }));
  const renderGraphAnswer = () => {
    const subPrompt = getSubPrompt();
    const isCompare = coreLC === "compare";
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      NumberLine,
      {
        rangeMin: problem.rangeMin,
        rangeMax: problem.rangeMax,
        places: problem.places,
        tickValues: problem.tickValues,
        markers: [problem.a, problem.b],
        step: problem.step
      }
    ), /* @__PURE__ */ React.createElement("p", { style: { textAlign: "center", fontSize: "clamp(14px, 3.5vw, 17px)", fontFamily: FONT, marginTop: 16, color: "#333" } }, subPrompt), isCompare ? renderCompareOptions(userAnswer, (v) => {
      if (!showResult) setUserAnswer(v);
    }, showResult) : renderChoiceOptions(userAnswer, (v) => {
      if (!showResult) setUserAnswer(v);
    }, showResult), !showResult && /* @__PURE__ */ React.createElement(CheckBtn, { onClick: handleSubmit, disabled: !userAnswer }), showResult && isCorrect && /* @__PURE__ */ React.createElement(CorrectMsg, null), showResult && !isCorrect && /* @__PURE__ */ React.createElement(WrongMsg, { explanation: getExplanation(problem, problem.taskType), onUnderstood: handleRetry }));
  };
  const renderDirect = () => {
    const isCompare = problem.taskType === "compare";
    const isCloser = problem.taskType === "closerTo";
    const prompt = isCloser ? `\u049A\u0430\u0439 \u0441\u0430\u043D ${ft} \u0441\u0430\u043D\u044B\u043D\u0430 \u0436\u0430\u049B\u044B\u043D?` : problem.taskType === "greater" ? "\u049A\u0430\u0439 \u0441\u0430\u043D \u04AF\u043B\u043A\u0435\u043D?" : problem.taskType === "smaller" ? "\u049A\u0430\u0439 \u0441\u0430\u043D \u043A\u0456\u0448\u0456?" : "";
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      NumberLine,
      {
        rangeMin: problem.rangeMin,
        rangeMax: problem.rangeMax,
        places: problem.places,
        tickValues: problem.tickValues,
        markers: [problem.a, problem.b],
        step: problem.step
      }
    ), isCompare ? renderCompareOptions(userAnswer, (v) => {
      if (!showResult) setUserAnswer(v);
    }, showResult) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", { style: { textAlign: "center", fontSize: "clamp(14px, 3.5vw, 17px)", fontFamily: FONT, marginTop: 16, color: "#333" } }, prompt), renderChoiceOptions(userAnswer, (v) => {
      if (!showResult) setUserAnswer(v);
    }, showResult)), !showResult && /* @__PURE__ */ React.createElement(CheckBtn, { onClick: handleSubmit, disabled: !userAnswer }), showResult && isCorrect && /* @__PURE__ */ React.createElement(CorrectMsg, null), showResult && !isCorrect && /* @__PURE__ */ React.createElement(WrongMsg, { explanation: getExplanation(problem), onUnderstood: handleRetry }));
  };
  return /* @__PURE__ */ React.createElement("div", { ref: containerRef, style: {
    minHeight: "100vh",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    background: "#f5f5f5",
    padding: 16,
    boxSizing: "border-box"
  } }, /* @__PURE__ */ React.createElement("div", { style: {
    background: "#fff",
    borderRadius: 10,
    padding: "clamp(16px, 4vw, 32px)",
    maxWidth: 540,
    width: "100%",
    boxSizing: "border-box",
    boxShadow: "0 1px 6px rgba(0,0,0,0.08)"
  } }, /* @__PURE__ */ React.createElement("h1", { style: {
    fontSize: "clamp(16px, 4.5vw, 22px)",
    fontFamily: FONT,
    color: "#333",
    textAlign: "center",
    margin: "0 0 20px",
    fontWeight: 600,
    lineHeight: 1.3
  } }, getTitle(problem.taskType)), isGraph ? graphPhase === "place" ? renderGraphPlace() : renderGraphAnswer() : renderDirect()));
};

            
            // Рендерим компонент
            ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(DecimalNumberLine));
            
            // Отправляем INIT сообщение
            if (embedMode && window.parent) {
                window.parent.postMessage({ type: 'INIT', status: 'ready' }, '*');
            }
        })();
    </script>
</body>
</html>